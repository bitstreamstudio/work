/*
 *  Copyright (c) 2016, https://github.com/nebula-im/nebula
 *  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef BASE_DH_UTIL_H_
#define BASE_DH_UTIL_H_

#include <stdint.h>
#include <openssl/bn.h>
#include <openssl/dh.h>

#include <folly/Range.h>

/**
  参考：http://blog.csdn.net/fw0124/article/details/8462373

  Diffie-Hellman算法：
  假如用户A和用户B希望交换一个密钥。
  取素数p和整数a，a是p的一个原根，公开a和p。
  A选择随机数XA<p，并计算YA=a^XA mod p。
  B选择随机数XB<p，并计算YB=a^XB mod p。
  每一方都将X保密而将Y公开让另一方得到。
  A计算密钥的方式是：K=(YB) ^XA modp
  B计算密钥的方式是：K=(YA) ^XB modp
  证明：
  (YB)^ XA mod p = (a^XB modp)^ XA mod p
  = (a^XB)^ XA mod p = (a^XA) ^XB mod p    (<-- 密钥即为 a^(XA*XB) mod p)
  =(a^XA modp)^ XB mod p= (YA) ^XB mod p
  由于XA和XB是保密的，而第三方只有p、a、YB、YA可以利用，只有通过取离散对数来确定密钥，但对于大的素数p，计算离散对数是十分困难的。
 
  例子：
  假如用户Alice和用户Bob希望交换一个密钥。
  取一个素数p =97和97的一个原根a=5。
  Alice和Bob分别选择秘密密钥XA=36和XB=58，并计算各自的公开密钥：
  YA=a^XA mod p=5^36 mod 97=50
  YB=a^XB mod p=5^58 mod 97=44
  Alice和Bob交换了公开密钥之后，计算共享密钥如下：
  Alice：K=(YB) ^XA mod p=44^36 mod 97=75
  Bob：K=(YA) ^XB mod p=50^58 mod 97=75
 */

// https://core.telegram.org/mtproto/samples-auth_key
// telegram 默认PQ,P,Q
// 暂用此PQ,P,Q
const uint8_t kDefaultPQ[8] = {0x17, 0xED, 0x48, 0x94, 0x1A, 0x08, 0xF9, 0x81};
const uint8_t kDefaultP[4] = {0x49, 0x4C, 0x55, 0x3B};
const uint8_t kDefaultQ[4] = {0x53, 0x91, 0x10, 0x73};

const int64_t kDefaultFingerprint = 0xc3b42b026ce86b21;

uint64_t gcd(uint64_t a, uint64_t b);
bool factorizeValue(uint64_t what, uint32_t &p, uint32_t &q);
bool check_prime(BIGNUM *p);
bool isGoodPrime(BIGNUM *p, uint32_t g);
bool isGoodGaAndGb(BIGNUM *g_a, BIGNUM *p);

// The following was auto-generated by
//  openssl dhparam -C 2048
class DH2048Wrapper {
public:
  DH2048Wrapper();
  ~DH2048Wrapper() {
    if (dh_) DH_free(dh_);
    dh_ = nullptr;
  }
  
  static uint32_t GetDH2048_G() {
    return dh2048_g[0];
  }
  
  static uint8_t* GetDH2048_P() {
    return dh2048_p;
  }

  static int GetDH2048_Bits() {
    return 2048;
  }
  
private:
  static unsigned char dh2048_p[];
  static unsigned char dh2048_g[];

  DH *dh_ {nullptr};
};

/*
DH *get_dh2048() {
  static unsigned char dh2048_p[]={
    0xF8,0x87,0xA5,0x15,0x98,0x35,0x20,0x1E,0xF5,0x81,0xE5,0x95,
    0x1B,0xE4,0x54,0xEA,0x53,0xF5,0xE7,0x26,0x30,0x03,0x06,0x79,
    0x3C,0xC1,0x0B,0xAD,0x3B,0x59,0x3C,0x61,0x13,0x03,0x7B,0x02,
    0x70,0xDE,0xC1,0x20,0x11,0x9E,0x94,0x13,0x50,0xF7,0x62,0xFC,
    0x99,0x0D,0xC1,0x12,0x6E,0x03,0x95,0xA3,0x57,0xC7,0x3C,0xB8,
    0x6B,0x40,0x56,0x65,0x70,0xFB,0x7A,0xE9,0x02,0xEC,0xD2,0xB6,
    0x54,0xD7,0x34,0xAD,0x3D,0x9E,0x11,0x61,0x53,0xBE,0xEA,0xB8,
    0x17,0x48,0xA8,0xDC,0x70,0xAE,0x65,0x99,0x3F,0x82,0x4C,0xFF,
    0x6A,0xC9,0xFA,0xB1,0xFA,0xE4,0x4F,0x5D,0xA4,0x05,0xC2,0x8E,
    0x55,0xC0,0xB1,0x1D,0xCC,0x17,0xF3,0xFA,0x65,0xD8,0x6B,0x09,
    0x13,0x01,0x2A,0x39,0xF1,0x86,0x73,0xE3,0x7A,0xC8,0xDB,0x7D,
    0xDA,0x1C,0xA1,0x2D,0xBA,0x2C,0x00,0x6B,0x2C,0x55,0x28,0x2B,
    0xD5,0xF5,0x3C,0x9F,0x50,0xA7,0xB7,0x28,0x9F,0x22,0xD5,0x3A,
    0xC4,0x53,0x01,0xC9,0xF3,0x69,0xB1,0x8D,0x01,0x36,0xF8,0xA8,
    0x89,0xCA,0x2E,0x72,0xBC,0x36,0x3A,0x42,0xC1,0x06,0xD6,0x0E,
    0xCB,0x4D,0x5C,0x1F,0xE4,0xA1,0x17,0xBF,0x55,0x64,0x1B,0xB4,
    0x52,0xEC,0x15,0xED,0x32,0xB1,0x81,0x07,0xC9,0x71,0x25,0xF9,
    0x4D,0x48,0x3D,0x18,0xF4,0x12,0x09,0x32,0xC4,0x0B,0x7A,0x4E,
    0x83,0xC3,0x10,0x90,0x51,0x2E,0xBE,0x87,0xF9,0xDE,0xB4,0xE6,
    0x3C,0x29,0xB5,0x32,0x01,0x9D,0x95,0x04,0xBD,0x42,0x89,0xFD,
    0x21,0xEB,0xE9,0x88,0x5A,0x27,0xBB,0x31,0xC4,0x26,0x99,0xAB,
    0x8C,0xA1,0x76,0xDB,
  };
 
  static unsigned char dh2048_g[]={
    0x02,
  };
  DH *dh;
  
  if ((dh=DH_new()) == nullptr) return(nullptr);
  dh->p=BN_bin2bn(dh2048_p,(int)sizeof(dh2048_p),nullptr);
  dh->g=BN_bin2bn(dh2048_g,(int)sizeof(dh2048_g),nullptr);
  if ((dh->p == nullptr) || (dh->g == nullptr))
    { DH_free(dh); return(nullptr); }
  return(dh);
}
 */

#endif // BASE_DH_UTIL_H_

